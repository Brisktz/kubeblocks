// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.2
// source: service_plugin.proto

package plugin

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ServicePluginClient is the client API for ServicePlugin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServicePluginClient interface {
	GetPluginInfo(ctx context.Context, in *GetPluginInfoRequest, opts ...grpc.CallOption) (*GetPluginInfoResponse, error)
	// IsServiceReady defines the mechanism to probe the readiness of the database.
	IsServiceReady(ctx context.Context, in *IsServiceReadyRequest, opts ...grpc.CallOption) (*IsServiceReadyResponse, error)
	// GetRole defines the mechanism to probe the role of replicas. The return role
	// must be one of the names defined in the componentdefinition roles.
	GetRole(ctx context.Context, in *GetRoleRequest, opts ...grpc.CallOption) (*GetRoleResponse, error)
	// MemberJoin defines how to add a new replica to the replication group.
	// This action is typically invoked when a new replica needs to be added,
	// such as during scale-out. It may involve updating configuration,
	// notifying other members, and ensuring data consistency.
	JoinMember(ctx context.Context, in *JoinMemberRequest, opts ...grpc.CallOption) (*JoinMemberResponse, error)
	// MemberLeave defines how to remove a replica from the replication group.
	// This action is typically invoked when a replica needs to be removed,
	// such as during scale-in. It may involve configuration updates and notifying
	// other members about the departure,
	LeaveMember(ctx context.Context, in *LeaveMemberRequest, opts ...grpc.CallOption) (*LeaveMemberResponse, error)
	// Readonly defines how to set a replica service as read-only.
	Readonly(ctx context.Context, in *ReadonlyRequest, opts ...grpc.CallOption) (*ReadonlyResponse, error)
	// Readwrite defines how to set a replica service as read-write.
	Readwrite(ctx context.Context, in *ReadwriteRequest, opts ...grpc.CallOption) (*ReadwriteResponse, error)
	// AccountProvision Defines the procedure to generate a new database account.
	AccountProvision(ctx context.Context, in *AccountProvisionRequest, opts ...grpc.CallOption) (*AccountProvisionResponse, error)
	// Switchover defines the procedure to switch replica roles in a primary-secondary
	// HA DBEngine by promoting the secondary to primary and demoting the current primary to secondary.
	Switchover(ctx context.Context, in *SwitchoverRequest, opts ...grpc.CallOption) (*SwitchoverResponse, error)
}

type servicePluginClient struct {
	cc grpc.ClientConnInterface
}

func NewServicePluginClient(cc grpc.ClientConnInterface) ServicePluginClient {
	return &servicePluginClient{cc}
}

func (c *servicePluginClient) GetPluginInfo(ctx context.Context, in *GetPluginInfoRequest, opts ...grpc.CallOption) (*GetPluginInfoResponse, error) {
	out := new(GetPluginInfoResponse)
	err := c.cc.Invoke(ctx, "/plugin.v1.ServicePlugin/GetPluginInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *servicePluginClient) IsServiceReady(ctx context.Context, in *IsServiceReadyRequest, opts ...grpc.CallOption) (*IsServiceReadyResponse, error) {
	out := new(IsServiceReadyResponse)
	err := c.cc.Invoke(ctx, "/plugin.v1.ServicePlugin/IsServiceReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *servicePluginClient) GetRole(ctx context.Context, in *GetRoleRequest, opts ...grpc.CallOption) (*GetRoleResponse, error) {
	out := new(GetRoleResponse)
	err := c.cc.Invoke(ctx, "/plugin.v1.ServicePlugin/GetRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *servicePluginClient) JoinMember(ctx context.Context, in *JoinMemberRequest, opts ...grpc.CallOption) (*JoinMemberResponse, error) {
	out := new(JoinMemberResponse)
	err := c.cc.Invoke(ctx, "/plugin.v1.ServicePlugin/JoinMember", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *servicePluginClient) LeaveMember(ctx context.Context, in *LeaveMemberRequest, opts ...grpc.CallOption) (*LeaveMemberResponse, error) {
	out := new(LeaveMemberResponse)
	err := c.cc.Invoke(ctx, "/plugin.v1.ServicePlugin/LeaveMember", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *servicePluginClient) Readonly(ctx context.Context, in *ReadonlyRequest, opts ...grpc.CallOption) (*ReadonlyResponse, error) {
	out := new(ReadonlyResponse)
	err := c.cc.Invoke(ctx, "/plugin.v1.ServicePlugin/Readonly", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *servicePluginClient) Readwrite(ctx context.Context, in *ReadwriteRequest, opts ...grpc.CallOption) (*ReadwriteResponse, error) {
	out := new(ReadwriteResponse)
	err := c.cc.Invoke(ctx, "/plugin.v1.ServicePlugin/Readwrite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *servicePluginClient) AccountProvision(ctx context.Context, in *AccountProvisionRequest, opts ...grpc.CallOption) (*AccountProvisionResponse, error) {
	out := new(AccountProvisionResponse)
	err := c.cc.Invoke(ctx, "/plugin.v1.ServicePlugin/AccountProvision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *servicePluginClient) Switchover(ctx context.Context, in *SwitchoverRequest, opts ...grpc.CallOption) (*SwitchoverResponse, error) {
	out := new(SwitchoverResponse)
	err := c.cc.Invoke(ctx, "/plugin.v1.ServicePlugin/Switchover", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServicePluginServer is the server API for ServicePlugin service.
// All implementations must embed UnimplementedServicePluginServer
// for forward compatibility
type ServicePluginServer interface {
	GetPluginInfo(context.Context, *GetPluginInfoRequest) (*GetPluginInfoResponse, error)
	// IsServiceReady defines the mechanism to probe the readiness of the database.
	IsServiceReady(context.Context, *IsServiceReadyRequest) (*IsServiceReadyResponse, error)
	// GetRole defines the mechanism to probe the role of replicas. The return role
	// must be one of the names defined in the componentdefinition roles.
	GetRole(context.Context, *GetRoleRequest) (*GetRoleResponse, error)
	// MemberJoin defines how to add a new replica to the replication group.
	// This action is typically invoked when a new replica needs to be added,
	// such as during scale-out. It may involve updating configuration,
	// notifying other members, and ensuring data consistency.
	JoinMember(context.Context, *JoinMemberRequest) (*JoinMemberResponse, error)
	// MemberLeave defines how to remove a replica from the replication group.
	// This action is typically invoked when a replica needs to be removed,
	// such as during scale-in. It may involve configuration updates and notifying
	// other members about the departure,
	LeaveMember(context.Context, *LeaveMemberRequest) (*LeaveMemberResponse, error)
	// Readonly defines how to set a replica service as read-only.
	Readonly(context.Context, *ReadonlyRequest) (*ReadonlyResponse, error)
	// Readwrite defines how to set a replica service as read-write.
	Readwrite(context.Context, *ReadwriteRequest) (*ReadwriteResponse, error)
	// AccountProvision Defines the procedure to generate a new database account.
	AccountProvision(context.Context, *AccountProvisionRequest) (*AccountProvisionResponse, error)
	// Switchover defines the procedure to switch replica roles in a primary-secondary
	// HA DBEngine by promoting the secondary to primary and demoting the current primary to secondary.
	Switchover(context.Context, *SwitchoverRequest) (*SwitchoverResponse, error)
	mustEmbedUnimplementedServicePluginServer()
}

// UnimplementedServicePluginServer must be embedded to have forward compatible implementations.
type UnimplementedServicePluginServer struct {
}

func (UnimplementedServicePluginServer) GetPluginInfo(context.Context, *GetPluginInfoRequest) (*GetPluginInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPluginInfo not implemented")
}
func (UnimplementedServicePluginServer) IsServiceReady(context.Context, *IsServiceReadyRequest) (*IsServiceReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsServiceReady not implemented")
}
func (UnimplementedServicePluginServer) GetRole(context.Context, *GetRoleRequest) (*GetRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRole not implemented")
}
func (UnimplementedServicePluginServer) JoinMember(context.Context, *JoinMemberRequest) (*JoinMemberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinMember not implemented")
}
func (UnimplementedServicePluginServer) LeaveMember(context.Context, *LeaveMemberRequest) (*LeaveMemberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveMember not implemented")
}
func (UnimplementedServicePluginServer) Readonly(context.Context, *ReadonlyRequest) (*ReadonlyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Readonly not implemented")
}
func (UnimplementedServicePluginServer) Readwrite(context.Context, *ReadwriteRequest) (*ReadwriteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Readwrite not implemented")
}
func (UnimplementedServicePluginServer) AccountProvision(context.Context, *AccountProvisionRequest) (*AccountProvisionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountProvision not implemented")
}
func (UnimplementedServicePluginServer) Switchover(context.Context, *SwitchoverRequest) (*SwitchoverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Switchover not implemented")
}
func (UnimplementedServicePluginServer) mustEmbedUnimplementedServicePluginServer() {}

// UnsafeServicePluginServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServicePluginServer will
// result in compilation errors.
type UnsafeServicePluginServer interface {
	mustEmbedUnimplementedServicePluginServer()
}

func RegisterServicePluginServer(s grpc.ServiceRegistrar, srv ServicePluginServer) {
	s.RegisterService(&ServicePlugin_ServiceDesc, srv)
}

func _ServicePlugin_GetPluginInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPluginInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServicePluginServer).GetPluginInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugin.v1.ServicePlugin/GetPluginInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServicePluginServer).GetPluginInfo(ctx, req.(*GetPluginInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServicePlugin_IsServiceReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsServiceReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServicePluginServer).IsServiceReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugin.v1.ServicePlugin/IsServiceReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServicePluginServer).IsServiceReady(ctx, req.(*IsServiceReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServicePlugin_GetRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServicePluginServer).GetRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugin.v1.ServicePlugin/GetRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServicePluginServer).GetRole(ctx, req.(*GetRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServicePlugin_JoinMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServicePluginServer).JoinMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugin.v1.ServicePlugin/JoinMember",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServicePluginServer).JoinMember(ctx, req.(*JoinMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServicePlugin_LeaveMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServicePluginServer).LeaveMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugin.v1.ServicePlugin/LeaveMember",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServicePluginServer).LeaveMember(ctx, req.(*LeaveMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServicePlugin_Readonly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadonlyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServicePluginServer).Readonly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugin.v1.ServicePlugin/Readonly",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServicePluginServer).Readonly(ctx, req.(*ReadonlyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServicePlugin_Readwrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadwriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServicePluginServer).Readwrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugin.v1.ServicePlugin/Readwrite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServicePluginServer).Readwrite(ctx, req.(*ReadwriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServicePlugin_AccountProvision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountProvisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServicePluginServer).AccountProvision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugin.v1.ServicePlugin/AccountProvision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServicePluginServer).AccountProvision(ctx, req.(*AccountProvisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServicePlugin_Switchover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServicePluginServer).Switchover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugin.v1.ServicePlugin/Switchover",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServicePluginServer).Switchover(ctx, req.(*SwitchoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ServicePlugin_ServiceDesc is the grpc.ServiceDesc for ServicePlugin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServicePlugin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugin.v1.ServicePlugin",
	HandlerType: (*ServicePluginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPluginInfo",
			Handler:    _ServicePlugin_GetPluginInfo_Handler,
		},
		{
			MethodName: "IsServiceReady",
			Handler:    _ServicePlugin_IsServiceReady_Handler,
		},
		{
			MethodName: "GetRole",
			Handler:    _ServicePlugin_GetRole_Handler,
		},
		{
			MethodName: "JoinMember",
			Handler:    _ServicePlugin_JoinMember_Handler,
		},
		{
			MethodName: "LeaveMember",
			Handler:    _ServicePlugin_LeaveMember_Handler,
		},
		{
			MethodName: "Readonly",
			Handler:    _ServicePlugin_Readonly_Handler,
		},
		{
			MethodName: "Readwrite",
			Handler:    _ServicePlugin_Readwrite_Handler,
		},
		{
			MethodName: "AccountProvision",
			Handler:    _ServicePlugin_AccountProvision_Handler,
		},
		{
			MethodName: "Switchover",
			Handler:    _ServicePlugin_Switchover_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service_plugin.proto",
}
